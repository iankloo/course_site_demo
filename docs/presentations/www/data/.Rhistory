new <- sample(1:100, 1)
num_searcher(start = new)
}
}
num_searcher(1)
num_searcher(90)
num_searcher(10)
num_searcher(10)
num_searcher(10)
num_searcher(10)
num_searcher(10)
num_searcher(10)
num_searcher(10)
num_searcher(10)
num_searcher(10)
num_searcher(10)
num_searcher(10)
start <- 1
start %% 11 != 0
start <- 1
while(start %% 11 != 0){
start <- sample(1:100, 1)
}
start
start <- 1
while(start %% 11 != 0){
start <- sample(1:100, 1)
}
start
start <- 1
while(start %% 11 != 0){
start <- sample(1:100, 1)
}
start
start <- 1
while(start %% 11 != 0){
start <- sample(1:100, 1)
}
start
start <- 1
while(start %% 11 != 0){
start <- sample(1:100, 1)
}
start
start <- 1
while(start %% 11 != 0){
start <- sample(1:100, 1)
}
start
start <- 1
while(start %% 11 != 0){
start <- sample(1:100, 1)
}
start
start <- 1
while(start %% 11 != 0){
start <- sample(1:100, 1)
}
start
start <- 1
start %% 11 == 0
num_search <- function(start){
if(start %% 11 == 0){
return(start)
} else{
new <- sample(1:100, 1)
num_search(start = new)
}
}
num_search(1)
num_search(1)
num_search(1)
num_search(1)
num_search(1)
num_search(1)
num_search(1)
num_search(1)
num_search(1)
num_search(1)
num_search(1)
num_search(1)
num_search(1)
num_search(1)
num_search(10)
num_search(11)
start <- 10
start %% 11 == 0
new <- sample(1:100, 1)
num_search(start = new)
10 == 10
10 = 10
10 == 10
10 = 10
10 <- 10
'hello' == 'hello'
'hello' == 'hello'
'hello' = 'hello'
hello
'hello' == 'hello'
10 == 20
'hello' == 'ello'
10 > 5
10 < 20
10 > 20
10 >= 10
10 == 5*2
10 != 10
10 != 20
10 == 20
10 != 20
2 == c(1,2,3,4)
2 %in% c(1,2,3,4)
!2 %in% c(1,2,3,4)
10 < 20
!10 < 20
x == 10
x <- 10
x == 10
x <- 10
if(x == 10){
print('yes')
}
if(x == 10) print('yes')
x <- 5
if(x == 10){
print('yes')
}
if(x == 10){
print('yes')
} else{
print('no')
}
x <- 5
if(x == 10){
print('yes')
} else if(x == 5){
print('no')
} else{
print('maybe')
}
x <- 10
if(x == 10){
print('yes')
} else if(x == 5){
print('no')
} else{
print('maybe')
}
x <- 2
if(x == 10){
print('yes')
} else if(x == 5){
print('no')
} else{
print('maybe')
}
pchisq(6.1, 5)
pchisq(6.1, 5, lower.tail = FALSE)
obs <- c(15,26,17,16,26,20)
rep(20,6)
exp <- c(20,20,20,20,20,20)
obs - exp
(obs - exp)^2
((obs - exp)^2)/exp
sum(((obs - exp)^2)/exp)
obs <- c(15,26,17,16,26,20)
exp <- c(20,20,20,20,20,20)
chisq <- sum(((obs - exp)^2)/exp)
df <- length(obs) - 1
pchisq(chisq, df, lower.tail = FALSE)
qchisq(.05,5)
dchisq(.05,5)
qchisq(.05,5, lower.tail = FALSE)
obs <- c(32,15,9,4)
mean(obs)
mean(obs) / 6-
mean(obs) / 60
mean(obs) / 60
1 - (mean(obs) / 60)
install.packages("twitteR")
library(twitteR)
consumer_key <- '4wZf6mtrPPHA2BR8csMHQMeMs'
consumer_secret <- 'qmBtAkqqeQ8WAMH4a1bITeBJYwbi3oH7DF06czdgUvaij6dNHR'
access_token <- '378633347-T2vg915E9uJlury9rUnovg80lsP0DvDY9xYNJZQT'
access_secret <- 'tHklkXpZmnTHLlUCJTqqWPC9D2XyJ8jxn6su4DKU288kt'
setup_twitter_oauth(consumer_key, consumer_secret, access_token, access_secret)
tweets <- searchTwitter("#hongkong",n=1000,lang="en")
df <- twListToDF(tweets)
View(df)
is.null(df$latitude[1])
df$latitude[1]
df[is.na(df$latitude) == FALSE, ]
?searchTwitter
tweets <- searchTwitter("#hongkong",n=500,lang="en", geocode = '22.3193, 114.1694, 150mi')
tweets <- searchTwitter("#hongkong",n=500,lang="en", geocode = '22.266181, 114.189891, 1000mi')
tweets <- searchTwitter("#hongkong",n=500,lang="en", geocode = '22.266181, 114.189891, 500mi')
tweets <- searchTwitter("#hongkong",n=500,lang="en", geocode = '55.792085, 37.614198, 500mi')
tweets <- searchTwitter("#hongkong",n=500,lang="en")
df <- twListToDF(tweets)
library(twitteR)
consumer_key <- '4wZf6mtrPPHA2BR8csMHQMeMs'
consumer_secret <- 'qmBtAkqqeQ8WAMH4a1bITeBJYwbi3oH7DF06czdgUvaij6dNHR'
access_token <- '378633347-T2vg915E9uJlury9rUnovg80lsP0DvDY9xYNJZQT'
access_secret <- 'tHklkXpZmnTHLlUCJTqqWPC9D2XyJ8jxn6su4DKU288kt'
setup_twitter_oauth(consumer_key, consumer_secret, access_token, access_secret)
tweets <- searchTwitter("#hongkong",n=500,lang="en")
df <- twListToDF(tweets)
View(df)
dpois(0, lambda = .75)
dpois(1, lambda = .75)
dpois(2, lambda = .75)
mat <- matrix(c(160,140,40,40,60,60), byrow = TRUE, nrow = 2)
mat
row.names(mat) <- c('hourly','salaried')
mat <- matrix(c(160,140,40,40,60,60), byrow = TRUE, nrow = 2)
mat
row.names(mat) <- c('hourly','salaried')
colnames(mat) <- c('p1','p2','p3')
mat
?t.test
chisq.test(mat, correct = FALSE)
setwd("C:/Users/Ian.Kloo/OneDrive - West Point/research/dota/dota")
library(knitr)
library(tidyverse)
library(corrplot)
library(viridis)
library(scales)
library(pROC)
library(caret)
library(gridExtra)
library(MLmetrics)
library(gridExtra)
library(boot)
library(plotly)
library(e1071)
opts_chunk$set(fig.align='center', warning = FALSE, message = F, echo = FALSE, include=T, fig.width=4, fig.height=3, fig.pos ='p')
# define default formatting that can be used in all figures.
## use bw theme, make some modifications, then set as default theme
att.theme = theme_bw() + theme(text=element_text(size=11)) + theme(plot.title = element_text(hjust = 0.5))
theme_set(att.theme)
## This chunk is optional and can be removed, but you may want to keep it since it helps make your figures more colorblind-friendly.
##
##
## Here we defines a colorblind friendly color palette for categorical variables
## from https://jacksonlab.agronomy.wisc.edu/2016/05/23/15-level-colorblind-friendly-palette/
## and set the default continuous color palette to a
## colorblind friendly palette from the package viridis
cb.pal =  c("#000000","#004949","#009292","#ff6db6","#ffb6db",
"#490092","#006ddb","#b66dff","#6db6ff","#b6dbff",
"#920000","#924900","#db6d00","#24ff24","#ffff6d")
#pie(rep(1,15), col=cb.pal) ## displays the colors
## replace the yellow with gray, since yellow is almost impossible to see on white paper.
cb.pal[15] = 'lightgray'
## remove the dark green.  It's too close to black when only two colors are needed.
cb.pal = cb.pal[-2]
n.cb = length(cb.pal)
#pie(rep(1,n.cb), col=cb.pal) ## displays the colors
## in case there are more than n.cb categories, repeat the colors, and add different shapes
cb.pal = rep(cb.pal, 5)
## This gives n circles, triangles, squares, upside down triangles, and diamonds
shapes = c(rep(21, n.cb), rep(24, n.cb), rep(22, n.cb), rep(25, n.cb), rep(23,n.cb))
## Use those to change the default color/fill/shape scales. Found this here:
## https://stackoverflow.com/questions/26019984/hot-to-change-set-global-scale-aesthetics-colours-for-ggplot
## Also, change the default continuous color palette to viridis.
## Note: Comment these out to use default color scales.
scale_colour_discrete   <- function(...) scale_color_manual(values=cb.pal) ## gotta use u in colour
scale_fill_discrete     <- function(...) scale_fill_manual( values=cb.pal)
scale_shape_discrete    <- function(...) scale_shape_manual(values=shapes)
scale_colour_continuous <- function(...) scale_color_viridis()
## Load data
n.sims=100
d    = readRDS('data/player.data.by.game.rds')
dt   = readRDS('data/team.data.by.game.rds')
dpc  = readRDS('data/player.stat.correlations.rds')
dtc  = readRDS('data/team.stat.correlations.rds')
dps  = readRDS('data/player.stats.rds') ## average box stats, and APM coefs
sims = readRDS(paste0('data/team.stats.', n.sims, '.sims.rds'))
coef = readRDS('data/coef.data.for.plotting.gold.rds')
n.mcmc=1500
head(d,2)
head(dt,2)
head(dpc,2)
head(dtc,2)
## remove st, if it is still there (it has hopefully already been moved though)
dpc = dpc %>% filter(!grepl('st', stat1) & !grepl('st', stat2))
dtc = dtc %>% filter(!grepl('st', stat1) & !grepl('st', stat2))
dtc = dtc %>%
group_by(stat1, stat2, n.games1, n.games2, n) %>%
summarise(cor=mean(cor)) %>% ## average over all sims
ungroup()
## Create a lookup table for converting abbreviations to full words for plots
abbrevs = c('k', 'd', 'a', 'lh', 'dn', 'gpm', 'xpm', 'lev', 'w',
'l', 'gp', 'str', 'agi', 'int', 'tot')
words = c('Kills', 'Deaths', 'Assists', 'Last.Hits', 'Denies',
'Gold', 'Exp', 'Level', 'Win', 'Loss',
'GP', 'Strength', 'Agility', 'Intelligence', 'Total')
stat.table =
data.frame(
abb  = c(abbrevs, paste0(abbrevs, '.f'), paste0(abbrevs, '.a'), paste0(abbrevs, '.d'   ), paste0(abbrevs, '.p')),
word = c(words  , paste0(words  , 'F' ), paste0(words  , 'A' ), paste0(words  , '.Diff'), paste0(words  , '%')),
stringsAsFactors = FALSE)
## define the stat columns we'll use most often
stat.cols = c('gpm', 'xpm', 'lev', 'k', 'a', 'lh', 'dn',  'd')
stat.cols.f=paste0(stat.cols, '.f')
stat.cols.a=paste0(stat.cols, '.a')
stat.cols.d=paste0(stat.cols, '.d')
stat.cols.p=paste0(stat.cols, '.p')
stat.cols.display   = stat.table$word[match(       stat.cols       , stat.table$abb)]
stat.cols.f.display = stat.table$word[match(paste0(stat.cols, '.f'), stat.table$abb)]
stat.cols.a.display = stat.table$word[match(paste0(stat.cols, '.a'), stat.table$abb)]
stat.cols.d.display = stat.table$word[match(paste0(stat.cols, '.d'), stat.table$abb)]
stat.cols.p.display = stat.table$word[match(paste0(stat.cols, '.p'), stat.table$abb)]
n.games = length(unique(d$game))
n.players = length(unique(d$player))
dd = d %>% count(player) %>% rename(GP=n) %>% arrange(desc(GP))
head(dd)
tail(dd)
max.gp = max(dd$GP)
min.gp = min(dd$GP)
n.teams = length(unique(dt$team.id))
team.gp = dt %>% group_by(team.id) %>% count() %>% rename(GP=n) %>% arrange(desc(GP))
#head(team.gp)
max.gp.team = max(team.gp$GP)
min.gp.team = min(team.gp$GP)
## Histogram of GP by player
hist.player = ggplot(dd, aes(x=GP))+
geom_histogram(binwidth=1)+
#ggtitle("Histogram of games played by player")+
ylab("Count")+xlab('Games Played')
## Histogram of GP by team
hist.team = ggplot(team.gp, aes(x=GP))+
geom_histogram(binwidth=1)+
#ggtitle('Histogram of Games Played for teams')+
xlab('Games Played') + ylab('Count')
grid.arrange(hist.player, hist.team, nrow=1,
top='Histogram of games played by player (left) and team (right)')
perc05 = round(nrow(dd[dd$GP< 5,])/nrow(dd), 2)
perc10 = round(nrow(dd[dd$GP<10,])/nrow(dd), 2)
## Number of heroes
n.heroes = length(unique(d$hero.id))
dd.hero = d %>% count(hero) %>% rename(GP=n) %>% arrange((GP))
dd.hero$hero = factor(dd.hero$hero, levels=dd.hero$hero)
dd.hero = rename(dd.hero,Hero=hero)
head(dd.hero)
tail(dd.hero)
dt <- as_tibble(dt)
ggplot(dt, aes(x=game.num, y=team.id))+
geom_point(alpha=0.1, size=0.5)+
xlab('Game ID') + ylab('Team ID')+
ggtitle('Team ID vs Game ID')
corr2 = cor(d[,stat.cols])
colnames(corr2) = stat.table$word[match(colnames(corr2), stat.table$abb)]
rownames(corr2) = colnames(corr2)
corrplot(corr2    , 'color', diag=F, addCoef.col = 'black', number.cex=.5, tl.cex=.5, cl.cex=.5, tl.col='black',
addgrid.col='gray', title='\n        Players', cex.main=.75, cl.pos='n')
dd=dpc
dd = dd %>%
mutate(stat1=gsub('[.]1', '', stat1),
stat2=gsub('[.]2', '', stat2)) %>%
filter(stat1 %in% stat.cols &
stat2 %in% stat.cols &
n.games1==n.games2)  ## the number of games in the first group of games is the same as the second group
dd$stat1 = stat.table$word[match(dd$stat1, stat.table$abb)]
dd$stat2 = stat.table$word[match(dd$stat2, stat.table$abb)]
dd = dd %>%
mutate(stat1=factor(stat1, stat.cols.display)) %>%
rename(Stat=stat1, Correlation=cor, Games=n.games1)
## stability, prediction
d.stab = dd %>% filter(Stat==stat2)
d.pred = dd %>% filter(stat2=='Gold')
shapes2 = rep(c(21, 24, 22, 25, 23), 2)
# ggplot(d.stab, aes(x=Games, y=Correlation, color=Stat, group=Stat, shape=Stat, fill=Stat))+
#   geom_line(size=.5)+geom_point()+scale_shape_manual(values=shapes2)+ylim(0,1)+
#   geom_line(data=d.stab[d.stab$Stat=='Gold',], aes(Games, Correlation), size=1, color='black')+
#   ggtitle('Stability of Player Statistics')
#
# ggplot(d.pred, aes(x=Games, y=(Correlation), color=Stat, group=Stat, shape=Stat, fill=Stat))+
#   geom_line(size=.5)+geom_point()+
#   scale_shape_manual(values=shapes2)+#ylim(0,1)+
#   geom_line(data=d.stab[d.stab$Stat=='Gold',], aes(Games, Correlation), size=1, color='black')+
#   ggtitle('Predictive ability of Player Statistics')
g.player.stab = ggplot(d.stab, aes(x=Games, y=Correlation, color=Stat, group=Stat, shape=Stat, fill=Stat))+
geom_line(size=.5, alpha=0.5)+geom_point(size=.5, alpha=0.5)+
scale_shape_manual(values=shapes2)+#ylim(-.1,1)+
geom_line(data=d.stab[d.stab$Stat=='Gold',],
aes(Games, Correlation), size=.75, color='black')+
theme(legend.position='none')+
scale_y_continuous(limits=c(-1,1), oob=squish)+
geom_hline(yintercept = 0, color='gray')
g.player.pred = ggplot(d.pred, aes(x=Games, y=Correlation, color=Stat, group=Stat, shape=Stat, fill=Stat))+
geom_line(size=.5, alpha=0.5)+geom_point(size=.5, alpha=0.5)+
scale_shape_manual(values=shapes2)+#ylim(-.1,1)+
geom_line(data=d.pred[d.pred$Stat=='Gold',],
aes(Games, Correlation), size=.75, color='black')+
theme(legend.title=element_blank())+
scale_y_continuous(limits=c(-1,1), oob=squish)+
geom_hline(yintercept = 0, color='gray')
#ggtitle('Ability of Team Statistics to Predict Gold Differential')
grid.arrange(g.player.stab, g.player.pred, nrow=1, heights=1, widths=c(1,1.5),
## need extra trailing spaces to avoid legend and to center it above the plots
top = "Stability (left) and predictive ability (right) of player statistics                ")
n.g=10
#temp = dpc %>%
#  mutate(stat1 = paste0(stat1, ' in first ', n.games1, ' games'),
#         stat2 = paste0(stat2, ' in first ', n.games2, ' games')) %>%
#  mutate(stat1 = factor(stat1, levels=unique(stat1)),
#         stat2 = factor(stat2, levels=unique(stat2))) %>%
dd=dpc
dd = dd %>% mutate(stat1=gsub('[.].', '', stat1),
stat2=gsub('[.].', '', stat2))
dd$stat1 = as.character(dd$stat1)
dd$stat2 = as.character(dd$stat2)
dd$stat1 = stat.table$word[match(dd$stat1, stat.table$abb)]
dd$stat2 = stat.table$word[match(dd$stat2, stat.table$abb)]
dd = dd %>% mutate(stat1=factor(stat1,stat.cols.display),
stat2=factor(stat2,stat.cols.display)) %>%
filter(n.games1==n.g & n.games2==n.g) %>%
select(stat1, stat2, cor) %>%
spread(key=stat2, value=cor)
head(dd)
corr.player.10 = as.data.frame(dd)
rownames(corr.player.10) = corr.player.10$stat1
corr.player.10 = select(corr.player.10, -stat1)
corr.player.10 = as.matrix(corr.player.10)
head(corr.player.10)
corrplot(corr.player.10    , 'color', diag=T, addCoef.col = 'black', number.cex=.5, tl.cex=.5, cl.cex=.5,tl.col='black',
addgrid.col='gray', cex.main=.5,
title=paste0('\n Correlations of player statistics,', n.g, ' games'))
temp = dt %>% ungroup() %>% select(w, stat.cols.d) %>% gather(key=Stat, value=value, -w) %>%
rename(Win=w, Value=value) # %>% mutate(Result=ifelse(Result==1,   'Win', 'Loss'),
#            Result=factor(Result   , c('Win', 'Loss')))
## convert stat abbrev into full words
temp$Stat = stat.table$word[match(temp$Stat, stat.table$abb)]
temp$Stat = factor(temp$Stat, levels = stat.cols.d.display)
head(temp)
ggplot(temp, aes(x=Value, y=Win))+
geom_jitter(height=0.3, alpha=0.03, size=.5, color='black')+
geom_smooth(method='glm',  method.args = list(family = "binomial"))+
facet_wrap(~Stat, scales='free_x', nrow=2)+
ggtitle('Scatter plot of wins vs various team statistics')
n.stat = length(stat.cols.d)
metrics = data.frame(Stat=factor(stat.cols.d.display, levels=rev(stat.cols.d.display)),
AUC=rep(NA, n.stat) ,
LogLoss=rep(NA, n.stat),
Accuracy=rep(NA, n.stat),
row.names=stat.cols.d)
for (stat in stat.cols.d){
formula = as.formula(paste('w ~ ', stat))
m1 = glm(formula, data=dt, family=binomial(link=logit))
## AUC
dt$pred = predict(m1, newdata=dt, type='response')
roc.obj <- roc(dt$w, dt$pred)
metrics[stat, 'AUC'] = round(auc(roc.obj),3)
## LogLoss
metrics[stat, 'LogLoss'] = round(LogLoss(y_pred = dt$pred, y_true = dt$w),3)
## Classification rate
dt$pred.cat=NA
dt$pred.cat[dt$pred< 0.5] = 0
dt$pred.cat[dt$pred>=0.5] = 1
cm=confusionMatrix(data=factor(dt$pred.cat), reference=factor(dt$w))
metrics[stat, "Accuracy"] = round(cm$overall['Accuracy'],3)
}
## format the metrics data for use with ggplot
temp = metrics %>% arrange(desc(LogLoss)) %>%
gather(key=Metric, value=Value, -Stat) %>%
mutate(Stat=factor(Stat,levels=unique(Stat)),
Metric=factor(Metric, levels=c('Accuracy', 'AUC', 'LogLoss')))
#temp$Stat = factor(temp$Stat,levels=temp$Stat)
head(temp,2)
ggplot(temp, aes(x=Stat, y=Value))+
geom_bar(stat='identity',  fill='gray95', color='darkgray', size=0.25) +
geom_text(aes(label=Value), hjust='left', size=2)+
scale_y_continuous(expand=c(.05, 0, .5, 0))+
facet_wrap(~Metric, scales='free_x')+coord_flip()+
theme(text=element_text(size=8))
ggplot(temp, aes(x=Stat, y=Value))+
geom_bar(stat='identity',  fill='gray95', color='darkgray', size=0.25) +
geom_text(aes(label=Value), hjust='left', size=2)+
scale_y_continuous(expand=c(.05, 0, .5, 0))+
facet_wrap(~Metric, scales='free_x')+coord_flip()+
theme(text=element_text(size=8))
ddt = dt %>% ungroup() %>% select(team.id, gpm, gpm.a, gp, w) %>%
mutate(Result=ifelse(w==1, 'Win', 'Loss'),
Result=factor(Result, levels=c('Win', 'Loss')))
ggplot(ddt, aes(x=gpm, y=gpm.a, color=Result))+
geom_abline(slope=1, intercept=0) +
geom_point(alpha=0.1) +
xlab('Gold For') + ylab("Gold Against")+
ggtitle('Gold For vs Gold Against for Teams, Single Games')
setwd("C:/Users/Ian.Kloo/OneDrive - West Point/courses/SE375/Fall_2019/Presentations/www/data")
nfl <- read.csv('nfl_points_wins.csv')
mod <- glm(win ~ points, data = nfl, family = binomial(link = 'logit'))
summary(mod)
challenger <- read.csv('challenger.csv')
mod <- glm(failure ~ temp, challenger, family = binomial(link = 'logit'))
summary(mod)
plot(mod$fitted.values, mod$residuals)
1/(1+exp(-(10.87535 - (0.17132 * 70))))
1/(1+exp(-(10.87535 - (0.17312 * 70))))
exp(-.17132)
plot(mod$fitted.values)
predict(mod, data.frame(temp = 70), type = 'response')
1/(1+exp(-(10.87535 - (0.17312 * 70))))
1/(1+exp(-(10.87535 - (0.17132 * 70))))
predict(mod, data.frame(temp = 70), type = 'response')
challenger <- read.csv('challenger.csv')
View(challenger)
mod <- glm(failure ~ temp, challenger, family = binomial(link = 'logit'))
summary(mod)
predict(mod, data.frame(temp = c(70,60)))
predict(mod, data.frame(temp = c(70,60)), type = 'response')
predict(mod, data.frame(temp = c(70,71)), type = 'response')
