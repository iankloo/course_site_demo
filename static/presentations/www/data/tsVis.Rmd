---
title: "Special Topic: Time Series Visualization"
author: "Ian Kloo"
date: "December 2019"
output:
    rmarkdown::html_document:
    theme: lumen
---

## Intro

As an analyst, you will come across time series data - probably often.  Knowing some tricks for munging (cleaning/working with) and visualizing time series data will serve you well.

This tutorial will cover the general topics you need to know to be able to work with and visualize time series data.  All code will be explained to give you a good understanding of what we are actually doing.  


## Data

The data for this tutorial comes from NOAA (National Oceanic and Atmospheric Administration).  It contains daily snowfall totals for Central Park.  Reading in the data:

```{r}
library(data.table)
snow <- fread('~/Downloads/noaa_snow_ny.csv')

head(snow)
```

We have a column for name (which we can disregard), a column for date, and a column with the amount of snow that fell that day (in inches).  For now, let's drop the name column, rename the other columns to lowercase, and move forward:

```{r}
snow <- snow[,c('DATE','SNOW')]
colnames(snow) <- c('date','snow')

head(snow)
```


## Dates in R: A huge pain

Aside from a few specialized software packages built for time series analysis, most scripting languages require some finesse to get dates working correctly.  Here is a quick run-down of how to work with dates in R.

Let's look at the date column of the snow data:

```{r}
head(snow)
```

Those look like dates, but they aren't:

```{r}
class(snow$date)
```

R thinks of these dates as characters.  This is a defense mechanism that R employs to make sure you can read in data of any type.  R doesn't assume your data is actually a date unless you specifically tell it to.  This should be familiar - Excel does the same thing.

Fortunately, just like Excel, R has a date class that you can convert to:

```{r}
snow$newDate <- as.Date(snow$date)

head(snow)
```

As you can see, the data doesn't look different, but R now knows that we want to treat the dates as dates.  Why does this matter?  Here's an example:

```{r, error = TRUE}
max(snow$date) - min(snow$date)

max(snow$newDate) - min(snow$newDate)
```

The first attempt fails because R doesn't know how to subtract characters from each other.  R does, however, know how to subtract dates.

This is just a small example to show you that formatting your data as a date is very important when working with time series data.  Let's rename our columns so that we only have one date column that contains properly formatted data:

```{r}
snow$date <- as.Date(snow$date)
snow$newDate <- NULL

head(snow)
```

## Time Series Data Structures

Time series data often arrives in a data frame with a row for each observation.  While the data looks clean, we need to take a closer look:

```{r}
snow[1:10,]
```

This data set only contains data when there is snow on a given day.  The days that don't have snow are simply left out of the data.  If you attempt to visualize this data, you might get something like this:

```{r}
barplot(snow$snow, names = snow$date)
```

This is definitely a representation of our data, but it is very misleading.  The x axis is supposed to represent dates, but it is only showing the dates where there was snow.  If we just want a visualization, we can solve the problem by using ggplot:

```{r, warning = FALSE, message = FALSE}
library(ggplot2)
ggplot(data = snow, aes(x = date, y = snow)) + geom_bar(stat = 'identity')
```

This is a much more realistic representation of our data.  It only snows a few days a year in NY - this is clear from looking at this visualization.  

In the above example, ggplot recognizes that there are holes in your data that you want to display.  Some packages are not so friendly, and you don't want to leave things up to chance, so you will want to reformat your time series data to include gaps.  The easiest way to do this is with a `tidyr` function called `complete()`:

```{r, warning = FALSE, message = FALSE}
library(tidyr)

snow <- complete(snow, date = seq.Date(min(date), max(date), by="day"))
snow$snow[is.na(snow$snow)] <- 0

print(snow)
```

OK, now our data represents a full daily time series.

## Moving between time steps (aggregation)

In R, we like to work with data frames because they are almost universally accepted by various functions and are familiar/easy to comprehend.  When working with time series data, it can be useful to use another data type called `xts` (extended time series).  This data type is slightly less intuitive and easy to grasp, but has some very useful properties.

We can take our data frame and create a new object using `xts`:

```{r, warning = FALSE, message = FALSE}
library(xts)
ts <- xts(snow$snow, order.by=snow$date)

head(ts)
```

This doesn't look too different from our data frame, but R now considers this to be a different class:

```{r}
class(ts)
```

These time series objects are very useful for a number of reasons.  One typical operation you will want to do with time series data is to aggregate the data to different time steps.  This can a big pain without using `xts`.  In `xts`, we can use the `apply.xxx` family of functions:


```{r, warning = FALSE, message = FALSE}
monthly <- apply.monthly(ts, sum)

head(monthly)
```

Now we have data that is aggregated to the month scale.  And similarly, we can translate to the annual scale:

```{r, warning = FALSE, message = FALSE}
annual <- apply.yearly(ts, sum)

head(annual)
```


That might seem somewhat easy to do without `xts`, but consider moving to a weekly scale:


```{r, warning = FALSE, message = FALSE}
weekly <- apply.weekly(ts, sum)

head(weekly)
```

This aggregation would have been very difficult without `xts`.  

Finally, you can easily translate back from a time series object to a data frame using:

```{r, warning = FALSE, message = FALSE}
annualDF <- fortify.zoo(annual)
colnames(annualDF) <- c('date','snow')

head(annualDF)
```

Moving between time steps easily is critical to good time series analysis.  It is easy to miss a trend if you are in the wrong scale.  For example, temperature in NY is seasonal, but it is only seasonal by month.  If you look at average annual temperatures, there is (almost) no trend in the data.

With weather, this is obvious because we live with weather every day.  However, you may not understand your data this well in practice.  The best idea is to try a few different aggregations when working with time series data to see if you can find anything interesting.

## Decomposition

Another popular method for dealing with time series data is decomposition.  The idea is to split out the seasonal oscillation in data, leaving you with a "true" trend line.

The easiest way to do this in R is to convert to a `ts` object and use the `decompose()` function:

```{r}
monthlyDF <- fortify.zoo(monthly)
colnames(monthlyDF) <- c('date','snow')

mo_ts <- ts(monthlyDF$snow, frequency = 12)

decomp <- decompose(mo_ts)
plot(decomp)
```

The trend appears to show some change over time, but it doesn't look like we are systematically getting more or less snow over time.

## Visualization

Why are we using bar charts?  Because we're using discrete time steps (as opposed to continuous time).

You will often see data visualized like this:

```{r, warning = FALSE, message = FALSE}
library(lubridate)
df <- annualDF[1:(nrow(annualDF)-1),]
df$year <- year(df$date)

ggplot(data = df, aes(x = year, y = snow)) + geom_line() + geom_point() +
  scale_x_continuous(breaks = df$year) + ylim(0,60)
```

This is a common, but bad representation of our data.  The problem is that we are using a continuous line to represent a discrete event.  For example, this plot suggests that it snowed about 5 inches between June and August of 2000...this is obviously not true.  Things like this are easy to see when it comes to snowfall, but could potentially be a big problem when you don't fully understand your data.  

This might seem like a weird thing to mention since you see data like this all the time, but you should be thinking hard about the way that you are representing data.  I will argue that this is a much better interpretation of the data:

```{r}
ggplot(data = df, aes(x = year, y = snow)) + geom_bar(stat = 'identity') +
  scale_x_continuous(breaks = df$year) + ylim(0,60)
```

Adding some finishing touches:

```{r}
ggplot(data = df, aes(x = year, y = snow)) + geom_bar(stat = 'identity') +
  scale_x_continuous(breaks = df$year) + ylim(0,60) +
  theme_minimal(base_size = 12) + ggtitle('Annual Snowfall in Central Park') +
  theme(axis.text.x = element_text(angle=45, hjust = 1), panel.grid.minor.x = element_blank(), plot.title = element_text(hjust = 0.5)) +
  ylab('Total Snowfall (in)') + xlab('Year')
```

### Interactive Plots

Interactive plots can be useful in presentations and applications.

You can easily make your `ggplots` interactive with `plotly` using `ggplotly()`:

```{r, warning = FALSE, message = FALSE}
library(plotly)

g <- ggplot(data = df, aes(x = year, y = snow)) + geom_bar(stat = 'identity') +
  scale_x_continuous(breaks = df$year) + ylim(0,60) +
  theme_minimal(base_size = 12) + ggtitle('Annual Snowfall in Central Park') +
  theme(axis.text.x = element_text(angle=45, hjust = 1), panel.grid.minor.x = element_blank(), plot.title = element_text(hjust = 0.5)) +
  ylab('Total Snowfall (in)') + xlab('Year')

ggplotly(g)
```


You can also use packages like `c3`:

```{r, warning = FALSE, message = FALSE}
library(c3)

df %>%
  c3(x = 'year', y = 'snow') %>%
  c3_bar() %>%
  grid('y')
```


Or `highcharter` (note, this `highcharts` requires a license for commercial use):

```{r, warning = FALSE, message = FALSE}
library(highcharter)

hchart(df, 'column', hcaes(x = 'year', y = 'snow'))
```






